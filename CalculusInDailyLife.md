# **《从代码到宇宙：CS学生的Python微积分探索手册》教学大纲 (增强版)**

### **课程理念**

本手册旨在打破传统微积分学习的抽象与枯燥，通过Python编程、数据可视化和源于生活的实例，让你不仅“知道”微积分，更能“理解”和“应用”它。我们将把微积分看作是一种描述和解决“变化”问题的强大思维框架，而Python是我们运用这一框架的利器。

### **环境要求**

  * Jupyter Notebook 或 VS Code with Jupyter extension
  * Python 3.x
  * **核心库:**
      * `numpy`：用于高效的数值计算和数据处理。
      * `matplotlib`：用于将函数、数据和结果可视化。
      * `sympy`：用于符号数学运算，帮助我们理解精确的数学公式。

-----

## **第一部分：微分学 —— 洞察变化的“显微镜” (`01_Derivatives.ipynb`)**

### **1.1 导数 (Derivative): 捕捉瞬时变化率**

#### **1.1.1 例子1：汽车的速度表**

  * **生活场景:** 你正驾驶汽车，某一瞬间，速度表显示“80 km/h”。
  * **推理过程:** 这个读数是汽车位置 `P(t)` 相对于时间 `t` 的**瞬时变化率**。导数就是用来精确描述这种“瞬间”变化的数学工具。
  * **数学表达式:**
      * 设路程为时间的函数: $$P(t) = 5t^2 + 20t$$
      * 瞬时速度 `v(t)` 是路程 `P(t)` 对时间 `t` 的导数:
        $$v(t) = P'(t) = \frac{d}{dt}P(t) = \frac{d}{dt}(5t^2 + 20t)$$
      * 根据求导法则，我们得到速度函数:
        $$v(t) = 10t + 20$$
      * 在 `t=3` 时刻的瞬时速度为:
        $$v(3) = 10(3) + 20 = 50 \text{ km/h}$$
  * **Python伪代码:**
    ```python
    import sympy as sp

    # 1. 定义时间为一个符号变量
    t = sp.Symbol('t')

    # 2. 定义路程函数 P(t)
    position_func = 5*t**2 + 20*t

    # 3. 对路程函数求导，得到瞬时速度函数 v(t)
    velocity_func = sp.diff(position_func, t)

    # 4. 计算在特定时刻 t=3 时的瞬时速度
    instant_velocity = velocity_func.subs(t, 3)

    print(f"路程函数 P(t) 是: {position_func}")
    print(f"速度函数 v(t) 是: {velocity_func}")
    print(f"在 t=3 时的瞬时速度是: {instant_velocity} km/h")
    ```
  * **原理解释:**
      * `sp.Symbol('t')` 创建了抽象的数学符号 `t`。
      * `sp.diff(function, variable)` 完美地执行了数学上的求导运算 `d/dt`，它精确地计算出导函数。
      * `.subs(variable, value)` 将具体数值代入符号函数，计算出该点的精确函数值，对应于计算 `v(3)`。

#### **1.1.2 例子2：App用户增长的“势头”**

  * **生活场景:** 分析新App的用户增长“势头”，以便向投资者汇报。
  * **推理过程:** “势头”就是总用户数 `U(t)` 在某一天的瞬时变化率。导数值越大，增长越快。
  * **数学表达式:**
      * 假设用户数随天数变化的函数为: $$U(t) = 100t^2 + 500t$$
      * 日增长率 `r(t)` 是总用户数 `U(t)` 的导数:
        $$r(t) = U'(t) = \frac{d}{dt}(100t^2 + 500t) = 200t + 500$$
      * 第10天时的增长“势头”为:
        $$r(10) = 200(10) + 500 = 2500 \text{ 用户/天}$$

#### **1.1.3 例子3：药物在体内的代谢速率**

  * **生活场景:** 病人服药后，医生需了解药物在血液中浓度 `C(t)` 的变化。
  * **推理过程:** 药物代谢的快慢，即血液中药物浓度的“瞬时下降速率”，是浓度函数 `C(t)` 的导数。
  * **数学表达式:**
      * 假设药物浓度随时间变化的函数为 (指数衰减): $$C(t) = 50e^{-0.5t}$$
      * 代谢速率 `R(t)` 是浓度 `C(t)` 的导数:
        $$R(t) = C'(t) = \frac{d}{dt}(50e^{-0.5t}) = 50 \cdot (-0.5)e^{-0.5t} = -25e^{-0.5t}$$
      * 在 `t=2` 小时后的代谢速率为:
        $$R(2) = -25e^{-0.5 \cdot 2} = -25e^{-1} \approx -9.2 \text{ (浓度单位/小时)}$$
      * 负号表示浓度正在下降。

### **1.2 偏导数 (Partial Derivative): 多因素下的单一变化**

#### **1.2.1 例子1：调节空调的舒适度**

  * **生活场景:** 房间的舒适度 `Comfort(T, H)` 由温度(T)和湿度(H)共同决定。
  * **推理过程:** 当你**只调低温度**，而不改变湿度时，舒适度的变化情况就是对 `T` 的偏导数。
  * **数学表达式:**
      * 假设舒适度函数为: $$C(T, H) = -(T - 25)^2 - 0.5(H - 60)^2$$
      * 舒适度对温度的偏导数为 (将H视为常数):
        $$\frac{\partial C}{\partial T} = \frac{\partial}{\partial T} \left[ -(T - 25)^2 - 0.5(H - 60)^2 \right] = -2(T - 25)$$
      * 舒适度对湿度的偏导数为 (将T视为常数):
        $$\frac{\partial C}{\partial H} = \frac{\partial}{\partial H} \left[ -(T - 25)^2 - 0.5(H - 60)^2 \right] = -1(H - 60)$$
  * **Python伪代码:**
    ```python
    import sympy as sp

    # 1. 定义温度和湿度为符号变量
    T, H = sp.symbols('T H')

    # 2. 定义舒适度函数
    comfort_func = - (T - 25)**2 - 0.5*(H - 60)**2

    # 3. 计算对温度的偏导数
    dC_dT = sp.diff(comfort_func, T)

    # 4. 计算对湿度的偏导数
    dC_dH = sp.diff(comfort_func, H)

    print(f"对温度的偏导数 ∂C/∂T 是: {dC_dT}")
    print(f"对湿度的偏导数 ∂C/∂H 是: {dC_dH}")
    ```
  * **原理解释:** `sp.diff(func, var)` 在处理多变量函数时，只需指定要求导的变量，`sympy` 就会自动将其他所有变量视为固定常数，完美执行偏导数的定义。

#### **1.2.2 例子2：游戏角色的属性加点**

  * **生活场景:** 游戏角色的战斗力 `P(S, A)` 由力量(S)和敏捷(A)决定。
  * **推理过程:** 当你**只加力量点**时，战斗力的提升值近似于对 `S` 的偏导数。
  * **数学表达式:**
      * 假设战斗力函数为: $$P(S, A) = 2S^2 + 1.5A^2 + SA$$
      * 战斗力对力量的偏导数为: $$\frac{\partial P}{\partial S} = 4S + A$$
      * 战斗力对敏捷的偏导数为: $$\frac{\partial P}{\partial A} = 3A + S$$

#### **1.2.3 例子3：在线广告的点击率**

  * **生活场景:** 广告点击率 `CTR(T, I)` 由标题吸引力(T)和图片质量(I)决定。
  * **推理过程:** A/B测试中，保持图片不变，**只测试不同标题**，分析的就是点击率对 `T` 的偏导数。
  * **数学表达式:**
      * 假设点击率函数为: $$CTR(T, I) = 0.01T \cdot \ln(I)$$
      * 对标题吸引力的偏导数为: $$\frac{\partial CTR}{\partial T} = 0.01 \ln(I)$$
      * 对图片质量的偏导数为: $$\frac{\partial CTR}{\partial I} = 0.01T \cdot \frac{1}{I}$$

### **1.3 梯度与梯度下降 (Gradient & Gradient Descent): 寻找最优解**

#### **1.3.1 例子1：AI模型训练**

  * **生活场景:** 训练一个最简单的线性回归模型 `y_pred = w*x + b` 来拟合数据。
  * **推理过程:**
    1.  定义“损失函数” `L(w, b)`，如均方误差，衡量模型预测值与真实值 `y_true` 的总差距。
    2.  我们的目标是找到让 `L` 最小的 `w` 和 `b`。
    3.  **梯度 `∇L`** 是一个向量 `(∂L/∂w, ∂L/∂b)`，指向 `L` 上升最快的方向。
    4.  因此，我们让参数 `w` 和 `b` 朝着**梯度的反方向 `-∇L`** 更新一小步。
  * **数学表达式:**
      * 损失函数: $$L(w, b) = \frac{1}{N}\sum_{i=1}^{N}(y_{true,i} - (wx_i + b))^2$$
      * 梯度向量: $$\nabla L = \left( \frac{\partial L}{\partial w}, \frac{\partial L}{\partial b} \right)$$
      * 更新规则 (梯度下降):
        $$w_{new} = w_{old} - \alpha \frac{\partial L}{\partial w}$$
        $$b_{new} = b_{old} - \alpha \frac{\partial L}{\partial b}$$
      * 其中 `α` 是学习率。
  * **Python伪代码:**
    ```python
    import numpy as np

    # 假设我们有数据点 x_data, y_data
    # 初始化参数 w, b, 学习率 alpha 和迭代次数
    w, b, alpha, iterations = 0, 0, 0.01, 1000

    for i in range(iterations):
        # 计算损失函数对 w 和 b 的偏导数 (梯度)
        # grad_w = ... (根据上面的公式计算)
        # grad_b = ... (根据上面的公式计算)
        
        # 更新参数：朝着梯度的反方向移动一小步
        w = w - alpha * grad_w
        b = b - alpha * grad_b
        
    print(f"训练完成, 最优参数是: w={w}, b={b}")
    ```
  * **原理解释:**
      * 这个循环是梯度下降的核心。`grad_w` 和 `grad_b` 组成了梯度向量。
      * `alpha`（学习率）控制了每一步的步长。
      * `w = w - ...` 这个减法操作，保证了我们是朝着梯度的**反方向**（下降最快的方向）更新参数。

#### **1.3.2 例子2：无人机寻找山谷最低点**

  * **生活场景:** 无人机需在崎岖山区自动寻找海拔最低点降落。
  * **推理过程:** 无人机测绘出地形高度函数 `h(x, y)`，计算梯度 `∇h`，然后朝着 `-∇h` 方向飞行。
  * **数学表达式:**
      * 地形函数: $$h(x, y) = 0.1x^2 + 0.2y^2 + 500$$
      * 梯度: $$\nabla h = (0.2x, 0.4y)$$
      * 无人机下一步移动方向: $$-\nabla h = (-0.2x, -0.4y)$$

#### **1.3.3 例子3：经济学中的利润最大化**

  * **生活场景:** 公司想通过调整价格 `p` 和广告投入 `a` 来最大化利润 `Profit(p, a)`。
  * **推理过程:** 计算利润函数的梯度 `∇Profit`，然后**顺着梯度方向**调整策略（梯度上升）。
  * **数学表达式:**
      * 利润函数: $$Profit(p, a) = -5p^2 + 50p + 20a - a^2$$
      * 梯度: $$\nabla Profit = (-10p + 50, 20 - 2a)$$
      * 调整方向: $$(p_{new}, a_{new}) = (p_{old}, a_{old}) + \alpha \nabla Profit$$

-----

## **第二部分：积分学 —— 汇聚变化的“累加器” (`02_Integration.ipynb`)**

### **2.1 不定积分与定积分: 从规律到总量**

#### **2.1.1 例子1：从变动的水流速率计算总流量**

  * **生活场景:** 水龙头的水流速度 `v(t)` 不稳，计算从0到10分钟的总流量。
  * **推理过程:** 总流量是流速对时间的累积。这在几何上等于速度-时间曲线下的面积。微积分基本定理告诉我们，这个面积可以通过找到速度函数的反导数（水量累计函数 `V(t)`）来计算。
  * **数学表达式:**
      * 假设流速函数: $$v(t) = 0.5t + 2 \text{ (升/分钟)}$$
      * **不定积分**求水量累计函数 `V(t)`:
        $$V(t) = \int v(t) dt = \int (0.5t + 2) dt = 0.25t^2 + 2t + C$$
      * **初始条件** `V(0)=0`，得 `C=0`。所以 `V(t) = 0.25t^2 + 2t`。
      * **定积分**求10分钟内的总流量 (应用微积分基本定理):
        $$\text{总流量} = \int_{0}^{10} (0.5t + 2) dt = V(10) - V(0)$$
        $$= (0.25(10)^2 + 2(10)) - (0) = 25 + 20 = 45 \text{ 升}$$
  * **Python伪代码:**
    ```python
    import sympy as sp
    import numpy as np

    # --- 符号解法 (理论精确) ---
    t = sp.Symbol('t')
    velocity_func = 0.5*t + 2

    # 计算从 t=0 到 t=10 的定积分
    total_volume_symbolic = sp.integrate(velocity_func, (t, 0, 10))
    print(f"精确的总流量是: {total_volume_symbolic} 升")

    # --- 数值解法 (现实模拟) ---
    time_points = np.linspace(0, 10, 1001) # 切成1000片
    velocity_points = 0.5*time_points + 2

    # 用梯形法则累加求和
    total_volume_numerical = np.trapz(velocity_points, time_points)
    print(f"数值计算的总流量是: {total_volume_numerical} 升")
    ```
  * **原理解释:**
      * `sp.integrate(func, (var, a, b))` 直接应用微积分基本定理，得到精确解。
      * `np.trapz(y, x)` 实现了梯形法则，将离散数据点间的区域看作微小梯形并累加其面积，以此来近似曲线下的总面积。

#### **2.1.2 例子2：从用电功率计算总电费**

  * **生活场景:** 家里的用电功率 `P(t)`（千瓦）变化，计算一个月总共用了多少度电（千瓦时）。
  * **推理过程:** 总电能 `E` 是功率 `P(t)` 对时间的定积分。
  * **数学表达式:**
      * 假设功率函数: $$P(t) = 1.5 + \sin(\frac{2\pi t}{24}) \text{ (kW)}$$
      * 一天（24小时）的总用电量: $$E = \int_{0}^{24} \left(1.5 + \sin(\frac{2\pi t}{24})\right) dt$$

#### **2.1.3 例子3：火箭发射**

  * **生活场景:** 火箭的加速度 `a(t)` 变化，计算发射后一段时间火箭达到的速度。
  * **推理过程:** 速度的变化量是加速度对时间的积分。
  * **数学表达式:**
      * 假设加速度函数: $$a(t) = 100 - 2t \text{ (m/s²)}$$
      * 从 `t=0` 到 `t=10` 秒的速度变化量 `Δv`:
        $$\Delta v = v(10) - v(0) = \int_{0}^{10} (100 - 2t) dt$$

-----

## **第三部分：高维积分 —— 从平面到空间 (`03_Multivariable_Integration.ipynb`)**

### **3.1 多重积分: 计算体积、质量与曲面面积**

#### **3.1.1 例子1：计算不规则山丘的土方量（体积）**

  * **生活场景:** 计算一座由 `z = f(x, y)` 描述的小山丘的总土方量。
  * **推理过程:** 我们将山丘的地面投影区域 `R` 切成无数个小方格 `dA = dx dy`。在每个小方格上，土方量约等于 `高度z × 底面积dA`。将所有这些小土方柱的体积加起来，就是二重积分。
  * **数学表达式:**
      * 山丘高度函数: $$z = f(x, y) = 100 - x^2 - y^2$$
      * 假设地面投影区域 `R` 是 `x \in [-5, 5], y \in [-5, 5]`。
      * 体积 `V` 通过二重积分计算:
        $$V = \iint_{R} f(x, y) dA = \int_{-5}^{5} \int_{-5}^{5} (100 - x^2 - y^2) dx dy$$
  * **Python伪代码:**
    ```python
    from scipy import integrate

    # 1. 定义山丘高度函数 z = f(x, y)
    def terrain_func(y, x): # 注意scipy的顺序是 y, x
        return 100 - x**2 - y**2

    # 2. 使用scipy的dblquad(二重积分)进行数值计算
    volume, error = integrate.dblquad(terrain_func, -5, 5, -5, 5)

    print(f"山丘的体积约是: {volume}")
    ```
  * **原理解释:**
      * `scipy.integrate.dblquad(func, x_min, x_max, y_min, y_max)` 是一个强大的二重积分数值计算工具。它在指定的矩形区域内，执行“堆叠细棍”法，将`terrain_func`（细棍的高度）在整个区域上进行累加求和。

#### **3.1.2 例子2：计算密度不均的物体的总质量**

  * **生活场景:** 一个金属部件，其密度 `ρ(x, y, z)` 在不同位置是不同的。
  * **推理过程:** 将物体切成小方块 `dV`。每个小方块的质量是 `密度ρ × 体积dV`。总质量是对密度函数的三重积分。
  * **数学表达式:**
      * 假设密度函数: $$\rho(x, y, z) = 5 + x^2 + y^2 + z^2$$
      * 假设物体 `B` 是一个单位立方体 `[0,1] \times [0,1] \times [0,1]`。
      * 总质量 `M` 通过三重积分计算:
        $$M = \iiint_{B} \rho(x, y, z) dV = \int_{0}^{1}\int_{0}^{1}\int_{0}^{1} (5 + x^2 + y^2 + z^2) dx dy dz$$

#### **3.1.3 例子3：计算不规则曲面的表面积**

  * **生活场景:** 为一座由 `z = f(x, y)` 描述的山脉铺设草皮，计算其真实的**表面积**。
  * **推理过程:** 由于山坡倾斜，真实的“草皮”面积 `dS` 会比其在地面上的影子 `dA` 要大。这个“拉伸系数”由偏导数决定。我们将所有被拉伸后的面积加起来。
  * **数学表达式:**
      * 山丘高度函数: $$z = f(x, y) = 10 - 0.1x^2 - 0.1y^2$$
      * 表面积微元: $$dS = \sqrt{1 + (\frac{\partial f}{\partial x})^2 + (\frac{\partial f}{\partial y})^2} dA$$
      * 经计算，$$\frac{\partial f}{\partial x} = -0.2x, \frac{\partial f}{\partial y} = -0.2y$$
      * 总表面积 `A` 为二重积分:
        $$A = \iint_{R} \sqrt{1 + (-0.2x)^2 + (-0.2y)^2} dA$$